/*=========================================================================*
 *				panic - 在文件main.c中				   *
 *	内核遇到了不可恢复的异常或错误，立即准备宕机
 *=========================================================================*/
PUBLIC void panic(
        _CONST char* msg,        /* 错误消息 */
        int error_no            /* 错误代码 */
){
    /* 当flyanx发现无法继续运行下去的故障时将调用它。典型的如无法读取一个很关键的数据块、
     * 检测到内部状态不一致、或系统的一部分使用非法参数调用系统的另一部分等。
     * 这里对printf的调用实际上是调用printk,这样当正常的进程间通信无法使用时核心仍能够
     * 在控制台上输出信息。
     */

    /* 有错误消息的话，请先打印 */
    if(msg != NIL_PTR){
        printf("\n!***** Flyanx kernel panic: %s *****!\n", msg);
        if(error_no != NO_NUM){
            printf("!*****     error no: %d     *****!", error_no);
        }
        printf("\n");
    }
    /* 好了，可以宕机了 */
    down_run();
}



/*=========================================================================*
 *				bad_assertion - 在文件misc.c中				   *
 *			    错误的断言处理
 *=========================================================================*/
PUBLIC void bad_assertion(
        char *file,         /* 断言失败代码所在文件 */
        int line,           /* 断言失败代码所在文件的哪一行？ */
        char *what          /* 断言源代码 */
){
    /* 本例程只有在宏DEBUG被定义为TRUE时才对其进行编译，支持assert.h中的宏。 */
    printf("\n\n*==============================================================================*");
    printf("* panic at file://%s(%d): assertion \"%s\" failed\n",
            file, line, what);
    printf("*==============================================================================*\n");
    panic("bad assertion", NO_NUM);
}

/*=========================================================================*
 *				bad_compare	- - 在文件misc.c中			   *
 *			  错误的断定比较处理
 *=========================================================================*/
PUBLIC void bad_compare(
        char *file,         /* 断定比较失败所在文件 */
        int line,           /* 断定比较失败代码所在文件的哪一行？ */
        int lhs,            /* 左边的比较数 */
        char *what,         /* 断定比较源代码 */
        int rhs             /* 右边的比较数 */
){
    /* 本例程只有在宏DEBUG被定义为TRUE时才对其进行编译，支持assert.h中的宏。 */
    printf("\n\n*==============================================================================*");
    printf("* \n\npanic at file://%s(%d): compare \"%s\" failed\n",
           file, line, what);
    printf("*==============================================================================*\n");
    panic("bad_compare", NO_NUM);
}

;============================================================================
;   系统进入宕机方法抽离execption - 在文件kernel.asm中
;----------------------------------------------------------------------------
exception:
	call	exception_handler
	add	esp, 4 * 2	    ; 让栈顶指向 EIP，堆栈中从顶向下依次是：EIP、CS、EFLAGS
    ret                 ; 系统已将异常解决，继续运行！
down_run:
    hlt
    jmp down_run

/*=========================================================================*
 *				exception_handler 在文件exception.c中				   *
 *			    异常处理例程
 *=========================================================================*/
PUBLIC void exception_handler(
        int int_vector,         /* 异常中断向量 */
        int error_no            /* 异常错误代码 */
){

    /* 非屏蔽中断，我们不予理睬 */
    if(int_vector == 2){
        printf("!********** Got spurious NMI! **********!\n");
        return;
    }

    /* 简单点，内核发生异常，我们准备宕机 */
    if(exception_table[int_vector] == NIL_PTR){
        panic("Exception no exist", NO_NUM);
    } else {
        panic(exception_table[int_vector], error_no != 0xffffffff ? error_no : NO_NUM);
    }

}

