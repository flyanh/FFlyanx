# 检查并得到计算机内存信息

​	我们现在在loader.bin程序内，同它的名字一样，它的功能就是负责做一些简单的加载工作，将真正的内核加载到内存中并转交控制权。但在那之前，我们最好先获取计算机的内存信息，因为Loader现在还处于16位实模式，它还能使用BIOS提供的中断功能，当我们进入32位保护模式的内核后，这些中断将无法再继续使用，所有功能都得自己编写了。所以在这为了以后的内存管理功能，计算机必须知道内存一共多大，有BIOS提供的中断功能，就能比较轻松的获取到计算机的内存信息。

## BIOS 15号中断

​	BIOS 15号中断提供的功能，可以让我们得到计算机的内存范围。

因为BIOS 15号中断的输入参数和输出参数比较多，我们分开讲述。

int 0x15的输入：

 - eax:      0x0000e820
- ebx:      放置“得到后续的内存信息的值”，第一次调用必须为0
- es:di:    指向一个物理地址，中断结束BIOS自动填充一个**地址范围描述符结构**(Address Range Descriptor Structure)
- ecx:      es:di所指向的**地址范围描述符**结构的大小，即BIOS将填充到es:di中多少个字节。但是，通常情况下无论ecx多大，BIOS一般只填充20个字节，甚至有电脑的BIOS根本就忽略ecx参数，总是填充20字节。
- edx:      0x0534d4150(字符串"SMAP")----固定的值，BIOS将会使用此标志，对调用者将要的系统映像(内存范围)进行校验，这些信息将会被BIOS放置到es:di所指向的结构中。

int 0x15的输出

 - CF:      CF=0表示没有错误，否则出现错误。
 - eax:    0x0534d4150("SMAP")
 - es:di:  和输入值一样，不变
 - ecx:     BIOS填充的字节量，一般返回最小值是20字节。
 - ebx:     放置着“后续的内存信息的值”，这个值没有规律，它依赖于具体BIOS的实现，我们不必关心它，只需要在下次迭代时将其放在ebx中，就可以通过它获取下一个**地址范围描述符**结构。但如果它的值为0，并且CF表示没错，那么它就是最后一个**地址范围描述符**。 

**地址范围描述符结构**(Address Range Descriptor Structure)，它占用20字节：

![](/media/flyan/Office/工程/FlyanxOS/操作系统之路-FlyanxOS-微内核向-教程/图片/ADRS.png)

而其中Type的意义如下：

![](/media/flyan/Office/工程/FlyanxOS/操作系统之路-FlyanxOS-微内核向-教程/图片/ADRS_Type.png)

​	有了这些知识，我们就可以马上编写代码，得到所有的**地址范围描述符结构**，将它们的长度加起来则是计算机的内存总大小！而且描述符中的其他属性也有可能被我们所使用到哦～





​	













​	



