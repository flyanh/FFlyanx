# 进程调度

​	微内核最重要的就是进程通信，进程通信设计要建立在完善的进程调度上的，对于我们之前实现的时间片轮转算法，不是一个很好的地基。

​	本节我们将完成我们系统的进程调度整体的算法实现。

## Flyanx的进程调度思路

​	Flyanx采用和MINIX2一样的进程调度算法，这个算法概括如下：

**调度算法维护三个优先级队列，分别对应系统任务、服务器进程和用户进程。最高优先级队列的第一个进程总是被选中执行。系统任务和服务器被允许执行到堵塞为止，但时钟中断则监视用户进程所使用的时间。若用户进程的时间片用完，它就被挂到其队列的尾部，这样便于在相互竞争的用户进程中达到了时间片轮转的调度效果。**

​	对于这个调度算法，提供了所有需要实现的功能框架如下：

```c
/* 进程正在切换则为TRUE，否则为FALSE；当为TRUE应该禁止硬件中断的产生，不然会
 * 产生一些严重的问题。
 */
PRIVATE bool_t switching = FALSE;

/* 本地函数声明 */
FORWARD _PROTOTYPE( void hunter, (void) );
FORWARD _PROTOTYPE( void schedule, (void) );

/*===========================================================================*
 *				     hunter   				     *
 *				  狩猎一个进程用于下次执行
 *===========================================================================*/
PRIVATE void hunter(void) {
    /* 从进程表中抓出一个作为下次运行的进程
     *
     * Flyanx使用和MINIX一样的三个就绪进程队列，分别是系统任务、系统服务、用户进程
     * 我们的调度算法很简单：找到优先级最高的非空队列，并选择队首进程即可。
     * 如果所有队列均为空，则运行闲置进程IDLE。
     *
     * 选择最高优先级队列由本例程完成。
     * 该函数的主要作用是设置curr_proc(系统当前运行的进程)，任何影响到选择
     * 下一个运行进程的对这些队列的改变都要再次调用hunter。无论进程在什么时
     * 候阻塞，都调用curr_proc来重新调度CPU。
     */
 	
}

/*===========================================================================*
 *				ready					     *
 *				进程就绪
 *===========================================================================*/
PUBLIC void ready(
        register Process_t* proc    /* 要就绪的进程 */
){
	
}

/*===========================================================================*
 *				unready					     *
 *				进程取消就绪
 *===========================================================================*/
PUBLIC void unready(
        register Process_t* proc    /* 堵塞的进程 */
){
    /* 将一个不再就绪的进程从其队列中删除，即堵塞。
     * 通常它是将队列头部的进程去掉，因为一个进程只有处于运行状态才可被阻塞。
     * unready 在返回之前要一般要调用 hunter。
     */
	
}

/*===========================================================================*
 *				schedule					     *
 *			     进程调度
 *===========================================================================*/
PRIVATE void schedule(void){
    /* 这个调度程序只针对于用户进程
     * 尽管多数调度决策实在一个进程阻塞或解除阻塞时作出的，但调度仍要考虑
     * 到当前用户进程时间片用完的情况。这种情况下，时钟任务调度 schedule 来将
     * 就绪用户进程队首的进程移到队尾。
     * 该算法的结果是将用户进程按时间片轮转方式运行。文件系统、内存管理器
     * 和I/O任务绝不会被放在队尾，因为它们肯定不会运行得太久。这些进程可以
     * 被认为是非常可靠的，因为它们是我们编写的，而且在完成要做的工作后将堵塞。
     */

   
}

/*===========================================================================*
 *				schedule_stop					     *
 *			     停止进程调度
 *===========================================================================*/
PUBLIC void schedule_stop(void) {
    /* 本例程只针对用户进程，使其用户进程不能再被调度,通常在系统宕机时
     * 本例程会被调用，因为这时候系统及其不可靠。本例程的实现也非常简单
     * ，让用户就绪队列为空即可，这样调度程序就找不到任何用户进程了。
     */

    ready_head[USER_QUEUE] = NIL_PROC;
}

/*==========================================================================*
 *				    lock_hunter				    *
 *				    加锁的，安全的进程狩猎例程
 *==========================================================================*/
PUBLIC void lock_hunter(void) {
    switching = TRUE;
    hunter();
    switching = FALSE;
}

/*==========================================================================*
 *				    lock_ready				    *
 *				    加锁的，安全的进程就绪例程
 *==========================================================================*/
PUBLIC void lock_ready(Process_t* proc) {
    switching = TRUE;
    ready(proc);
    switching = FALSE;
}

/*==========================================================================*
 *				lock_unready				    *
 *				加锁的，安全的进程堵塞例程
 *==========================================================================*/
PUBLIC void lock_unready(Process_t* proc) {
    switching = TRUE;
    unready(proc);
    switching = FALSE;
}

/*==========================================================================*
 *				lock_schedule				    *
 *				加锁的进程调度方法
 *==========================================================================*/
PUBLIC void lock_schedule(void)
{
    switching = TRUE;
    schedule();
    switching = FALSE;
}


/* 公有函数声明 */
/*================================================================================================*/
/* process.c */
/*================================================================================================*/
_PROTOTYPE( void lock_schedule, (void) );
_PROTOTYPE( void lock_unready, (struct process_s *proc) );
_PROTOTYPE( void lock_ready, (struct process_s *proc) );
_PROTOTYPE( void lock_hunter, (void) );
_PROTOTYPE( void schedule_stop, (void ) );
_PROTOTYPE( void ready, (struct process_s *proc) );
_PROTOTYPE( void unready, (struct process_s *proc) );
```

我们开始编写功能的代码实现。



