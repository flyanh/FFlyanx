# Hello Multiprocess

​	看标题，大家应该也猜到我们接下来的工作了...是的，我们马上让我们的系统开始不那么单一，到现在为止，我们的系统一直处于内核级代码，就内核一个人在默默的执行着，我们本节就要完成多个进程的初始化以及让它们执行起来。

## 初始化所有的进程的 LDT 信息

​	我们需要一个载体来进行存放我们的所有进程，这个我们上节已经完成了，就是我们的进程表 proc_table(在 process.h 头文件中声明并定义)，它是用来描述和装载我们整个系统的所有进程的。

​	我们上节已经谈过，进程的 PCB 结构中包含了栈帧和 LDT 信息，但是我们上节只处理了栈帧信息，完成了一个多进程框架，我们现在准备让我们的多进程可用，还必须得对 LDT 信息进行一下处理。

​	我们来到马上来到 protect.c 的初始化代码中，开始初始化我们进程表中所有进程的 LDT 信息，使得我们内核初始化时就分配给每个进程自己的 LDT。

## 系统进程表

​	现在，我们为了区分系统的进程和以后的用户进程，我们现在再创建一个系统进程表，它们用来存放和我们内核链接在一起的一些进程，我们统一称为系统进程，它需要一个结构表示，我们在这里给出：

```c
/* 系统进程表项定义
 *
 * 一个表项可以存放一个系统级别的进程，在这里我们和用户进程表项分开定义了
 * 因为它们特权级不同，待遇也不同，就这个理解就应该让我们区别对待。
 */
typedef struct sys_proc {
    task_t *initial_eip;        /* 系统进程的处理句柄，即 eip */
    int     stack_size;         /* 系统进程的栈大小 */
    char    name[16];           /* 系统进程名称 */
} SysProc_t;
```

​	有了这个表项，我们就马上将系统进程表创建出来，放在 table.c 中初始化，同时别忘了在 global.h 中声让内核可以知道该表在哪哦～

```c
/* === 系统进程表，包含系统任务以及系统服务 === */
PUBLIC SysProc_t sys_proc_table[] = {
        /* ************************* 系统任务 ************************* */

        /* ************************* 系统服务 ************************* */
};
```

## 创建AB两个系统任务做测试

​	没错，既然我们连赛道都准备好了，为什么不找几辆跑车来跑一跑，比一比赛呢？我们现在马上编写两个最基础的进程，让它们运行起来看看我们的成果吧！

​	对于这些无脑的代码，我们直接贴出，不要浪费宝贵的时间，AB两个进程体如下：

```c
/*=========================================================================*
 *				test_task_a				   *
 *	            测试系统任务 A
 *=========================================================================*/
PUBLIC void test_task_a(void) {
    int i, j, k;
    k = 0;
    while (TRUE) {
        for(i = 0; i < 100; i++)
            for(j = 0; j < 1000000; j++) {}
        printf("#{A}-> %d)", k++);
    }
}

/*=========================================================================*
 *				test_task_a				   *
 *	            测试系统任务 B
 *=========================================================================*/
PUBLIC void test_task_b(void) {
    int i, j, k;
    k = 0;
    while (TRUE) {
        for(i = 0; i < 100; i++)
            for(j = 0; j < 1000000; j++) {}
        printf("#{B}-> %d)", k++);
    }
}

// C 函数原型声明：
_PROTOTYPE( void test_task_a, (void) );
_PROTOTYPE( void test_task_b, (void) );
```

​	这两个进程足够简单，都是在一段空循环后，打印一段字符串表明自己的身份并打印出循环次数。但是其实这两个测试进程是很有必要设计成这样的，特别是打印处次数可以证明我们的多进程能够保存状态并恢复状态。

​	因为如果只是打印 AB 的话，会出现一种情况，看起来是在运行打印 AB 了，但是你设计的多进程框架并不能保存状态，你这时是不能从这些信息里面看出你错误的设计的，你会暗自窃喜自己的系统真的支持多进程了，殊不知你的多进程每次开始都是重新开始！

​	而一旦我们能看到打印的循环信息，它在不断的增大就说明每次进程切换前都能正常保存状态并恢复了，如果每次看到的都是初始值 0，说明系统的多进程框架有问题，并没有保存下进程被暂停时的状态。

​	好的，说了这么多，我在这想表达一种编程思想：**不要因为懒惰而去设计简单的测试，一时结果的正确可能会在未来让你对整个程序的 BUG 修复难以下手，因为你根本想不到这个 BUG 其实在很久以前就已经存在了，而我们一般只会考虑近期的代码问题。**

## 为系统进程添加堆栈信息

​	有了系统进程还远远不够，每个进程还需要一个属于自己的堆栈，因为一个进程往往很复杂，内部需要很多函数调用，它们都是需要栈来支持的。

​	很显然，虽然它们也属于系统，但在这里我们不应该也不允许它们和内核共用一个堆栈，我们马上创建一块空间专门用于分配堆栈给每个进程，在这，我直接给出，它们很简单：

```c
/* === 堆栈相关 === */
/* 一个 512 字节 的小栈 */
#define SMALL_STACK (128 * sizeof(char*))
/* 这是一个普通堆栈大小，1KB */
#define NORMAL_STACK (256 * sizeof(char*))

/* 所有系统进程的栈空间总大小 */
#define TOTAL_TASK_STACK    (0)

/* 所有系统进程堆栈的堆栈空间。 （声明为（char *）使其对齐。） */
PUBLIC char* sys_proc_stack[TOTAL_TASK_STACK / sizeof(char *)];
```

​	它们也是放在 table.c 中进行声明并定义空间的，所以也不要忘了在 global.h 中声明它们。

​	最后我们完成以下这几步：	

```c
// 为 AB 设置堆栈大小

// 将 AB 两个任务初始化到我们的表中

// 更新宏 NR_TASKS 的数量

// 更新宏 LOW_USER 的值，它表示所有特权级小于3的最小系统进程逻辑号，因为 A = -2，B = -1，所以 其应为 -1
```

## 将系统进程初始化到进程表中并初始化整个进程体的信息

​	我们做了那么多的准备，却还远远不够，我们整个系统是以进程表为基础设计的多进程，所以我们现在将系统进程初始化到进程表中，然后为它们初始化栈帧、进程体中其他属性等各种信息。

## 启动多进程

​	完事具备，经过上面的所有循环初始化，将会为每个系统进程分配堆栈、设置栈帧等所有信息，我们就差最后一步，设置 curr_proc 的值并调用 restart 将其启动起来了。

​	.............

​	我们经过上面的确启用了进程，但是很明显只有进程 A 和 时钟中断在打印，根本没有 B 鸟事情，其实稍微用屁股想一下就能很快明白，我们的 restart 是根据 curr_proc 来确定恢复执行哪个进程的，我们的 curr_proc 指向 A 之后，根本就没有变过，不是么？

​	那么我们该怎么让 B 也加入我们的大家庭？其实就是需要某个时间将 curr_proc 进行切换对吧？但谁来做这一份工作呢？当前是我们的内核代码，就不废话了，我们马上实现一个最简单的进程调度算法：时间片轮转算法，我们就让 1s 换一个人，只需要在我们原本的时钟中断里进行改进就好了，我们马上开始。

## 总结

​	我们走到了这步，可以看到我们的两个进程在运行了！完全符合我们的预期，我们看到了 AB 交替打印的字母和数字不停的出现在电脑屏幕上，中途时钟中断还偶尔打印个 > 来刷一下存在感，更是说明我们现在多进程的调度和内核代码在一块执行。

​	同时我们仔细看看，它们的打印交替间隔不是一直一致的，虽然表面的样子不是很好看，但对我们来说有着非同寻常的意义。回看当年的Linux 0.01，它也只是实现了两个进程在交替的运行，而现在，我们也做到了，不是吗？

​	一切的一切，意味着我们研究编写了这么久东西，已经真正可以被称之为“操作系统”了，因为“进程”是操作系统的灵魂所在，我们已经为 Flyanx 注入了灵魂。













​	































