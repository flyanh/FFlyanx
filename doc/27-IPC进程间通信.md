# IPC进程间通信

​	多进程的实现，是Flyanx的第一个里程碑，如果是要实现像Linux这样的宏内核，那么我们已然具备了成型的框架，接下来的开发就是使用函数实现功能模块即可。但它却还不是微内核的重点，微内核的思想是以进程为最小的模块单位来实现我们的操作系统功能，但问题紧接着就出现了，一个复杂的功能模块，常常需要其他的功能模块的功能一起实现的，如果进程独立之后，它应该如何得到其他进程的功能服务？首先宏内核那套就肯定不行了：通过函数调用去实现互相通信调用。

​	不能通过函数调用得到对方的服务。这个问题稍加思考就明白了，函数调用必须保证它们编译在一个文件中，可以看得到对方暴露的函数声明才能互相调用。而进程间呢？它们可能处于不同的代码、数据段，甚至于可能处于不同的计算机上，而且就算可以跨段访问，它们有可能CPU权限还不同，有可能对方是一个系统任务，拥有特权级1，对方也完全有可能是一个用户程序，处于3特权级。所以，对于微内核，必须有一种新的方式来使得进程间可以互相交流，以便合作实现一些复杂功能。这就是为什么需要消息通信了，它可以使两个进程可以互相发送消息，这样进程间就有了交流的方式，就可以完美解决微内核的通信问题。

​	IPC机制有很多，第一个是大家就是大家所熟知的信号机制，我们暂时不考虑信号的实现。我们接下来讨论的是消息通信机制。

## 消息通信原理

​	消息通信简单来说，每个进程都可以通过一个中间人给其他进程发送消息，而接收到消息的进程可以根据需要给出相应回应。其中这个中间人是非常重要的，它必须可靠且有最高权限，这样才能处理进程的任何权限进请求，而维护这一套流程的东西就叫消息通信机制。它就等同为日常生活中的写信，F现在需要H朋友的帮助，但H朋友在遥远的北方，于是F就写了一封信，然后投给邮局。几天后，邮局将这封信送到了H手上，H看完信里的内容后，马上帮F处理完事情后也写了一封信回给他，告诉F事情已经处理好了。而在这件事情中，邮局就是这个中间人，它必须非常可靠。

​	消息传递作为进程间通信的方式，它们使用两条原语SEND和RECEIVE。它们很容易被加入到系统库例程中。例如：

send(目的地, &消息); receive(源地址, &消息);

​	前一个调用向一个给定的目标发送一条消息，后一个则从一个给定的源接收一条消息。如果没有消息可用，则接收者应该被堵塞直到等的消息到达。

​	消息通信机制有很多变体，我们在这打算采取最简单也是最容易实现的一种实现策略：会和(rendezvous)原则。在这样的情况下消息传递完全没有缓冲，如果SEND在RECEIVE之前执行，则发送者被堵塞，直到对应的RECEIVE发生。执行RECEIVE时消息直接从发送者拷贝给接收者，不带有任何缓冲。同样，如果RECEIVE先执行，则接收者被堵塞直到SEND发生。虽然这种方案更容易实现，但灵活性却不佳，因为发送者和接收者必须要以一种步步紧接的方式运行。

## 消息拷贝

​	消息通信第一件考虑的事情就是消息拷贝，因为进程A传递消息给进程B需要将消息拷贝给进程B，这里我们其实可以使用我们以前编写的phys_copy来实现，但是这里我们注意，phys_copy效率并不高，因为它是按字节拷贝数据的。所以我们引入一个新的拷贝函数msg_copy，它只传输一个消息结构体，并且使用dword作为传输单位，效率更高，我在这直接给出。

```assembly
global msg_copy                 ; 消息拷贝
MESSAGE_SIZE    equ	9		        ; 消息的大小(dword)

;*===========================================================================*
;*				消息拷贝				     *
; 函数原型：PUBLIC void msg_copy(phys_bytes msg_phys, phys_bytes dest_phys);
; 虽然我们可以用 phys_copy 来进行消息的拷贝完成消息的传递，但是这样按字节传输的效率
; 对于我们的邮局来说效率太低了，这个函数专门用于消息拷贝，它使用了 movsd(拷贝单位: dword)
; 这样在 32位 模式下更快的传输指令，它能很大提升我们邮局的传信效率，但比起函数调用还是很慢。
;*===========================================================================*
align 16
msg_copy:
    push esi
    push edi
    push ecx

      mov esi, [esp + 4 * 4]  ; msg_phys
      mov edi, [esp + 4 * 5]  ; dest_phys

      ; 开始拷贝消息
      cld
      mov ecx, MESSAGE_SIZE   ; 消息大小(dword)
      rep movsd

    pop ecx
    pop edi
    pop esi
    ret
```

​	好的，有了msg_copy，我们可以继续了，但我们在前面指出一个问题：phys_copy效率不高，原因是因为它拷贝按字节。那么，我们能不能优化一下phys_copy?答案是肯定的，在这我们贴出改良版的phys_copy，它首先算出要拷贝数据的dword大小并按dword拷贝，然后再根据字节拷贝剩下的1~3个字节。不要小看这个新改动，数据拷贝是操作系统底层最常用的一项功能，该函数的效率提升代表者着我们操作系统整体效率的提升！

```assembly
;*===========================================================================*
;*				phys_copy				     *
;*===========================================================================*
; PUBLIC void phys_copy(phys_bytes src, phys_bytes dest,
;			phys_bytes size);
;* 将物理内存中任意处的一个数据块拷贝到任意的另外一处 *
;* 参数中的两个地址都是绝对地址，也就是地址 0 确实表示整个地址空间的第一个字节， *
;* 并且三个参数均为无符号长整数 *
PC_ARGS     equ     16    ; 用于到达复制的参数堆栈的栈顶
align 16
phys_copy:
    push esi
    push edi
    push es

      ; 获得所有参数
      mov esi, [esp + PC_ARGS]            ; src
      mov edi, [esp + PC_ARGS + 4]        ; dest
      mov ecx, [esp + PC_ARGS + 4 + 4]    ; size
      ; 注：因为得到的就是物理地址，所以esi和edi无需再转换，直接就表示一个真实的位置。
      mov eax, ecx
      and eax, 0x3                        ; 得到 size / 4 的余数，肯定在 0~3 内，用与是为了速度
      shr ecx, 2                          ; 得到 size / 4 的结果，因为我们要执行 dword 的传输
      cld
      rep movsd                           ; 双字传输，效率第一！
      mov ecx, eax                        ; 好的，现在准备传输剩下的字节
      cld
      rep movsb                           ; 字节传输剩下的 0~3 个字节

    pop es
    pop edi
    pop esi
    ret
```

## Flyanx消息通信框架

​	对于 Flyanx 的消息通信，我的目标是实现一个简单且灵活的通信原语，我打算实现以下三个功能。

**in_outbox(收件箱地址，发件箱地址);**

​	对于in_outbox，它的功能是设置固定的收发件箱，什么意思呢？就是设置本进程的收发件地址，一旦设置成功，以后使用send和receive就可以直接发送或接收，如果是发送，默认使用固定的发件箱地址，接收同上。

**send(进程逻辑号， 发件地址);**

​	对于send，它可以发送一个消息到对应进程逻辑号的进程，后面的发件地址是可选项，如果不设置，即为NULL的话，我们使用in_outbox设置固定的发件地址；如果设置了则使用该发件地址，但是不会定固定收发件地址进行改动。

**receive(进程逻辑号， 收件地址);**

​	对于receive，它可以从对应进程逻辑号的进程接收一个消息，接收到的消息存放在收件地址中。收件地址同send一样，也是未设置使用默认的...

**send_rec(进程逻辑号，收发件地址)**

​	对于send_rec，它完成发送一条消息到对应进程逻辑号的进程并对等对方的回应消息，这里的收发件地址如果为NULL，则收发件地址使用默认固定的；如果设置了则代表使用设置的，它依旧不会更改固定收发件箱。

​	对于以上的几个功能原语，在这给出它们的调用号：

```c
/* 系统调用例程可以支持的操作 */
#define SEND            0x1    	/* 0001: 发送一条消息 */
#define RECEIVE         0x2    	/* 0010: 接收一条消息 */
#define SEND_REC        0x3    	/* 0011: 发送一条消息并等待对方响应一条消息 */
#define IN_OUTBOX       0x4   	/* 0100: 设置固定收发件箱  */
#define ANY             0x3ea   /* 魔数，它是一个不存在的进程逻辑编号，用于表示任何进程
                                 *      receive(ANY, msg_buf) 表示接收任何进程的消息
                                 */
```



​	好的，这就是我对于Flyanx消息通信框架的整体构思，我们马上来实现吧。

## 系统调用实现

​	对于这个中间件，我们首先使用软件中断来实现一个系统调用，这个系统调用根据上面不同的操作请求处理不同的通信原语。

​	当系统调用搞定后，我们根据不同的操作封装出上面的原语函数，它们的原型函数声明如下：

```c
_PROTOTYPE( int send_rec, (int src, Message_t *io_msg) );
_PROTOTYPE( int in_outbox, (Message_t *in_msg, Message_t *out_msg) );
_PROTOTYPE( int send, (int dest, Message_t* out_msg) );
_PROTOTYPE( int receive, (int src, Message_t* in_msg) );
```

​	然后我们在lib中创建一个新的文件用于封装。

## 消息通信实现

​	未完待续......



​	

















