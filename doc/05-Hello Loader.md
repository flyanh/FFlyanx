# Hello Loader

​	我们马上打破限制，加载一个简单的程序，它之后被被作为一个加载内核的程序，它将继续接手处理引导程序的工作。

## Loader加载位置

​	现在有了Loader程序，但是我们要思考一个问题，我们应该要将它加载到内存中的什么位置呢？我们马上看看计算机的内存分布。

​	!![](/media/flyan/Office/工程/FlyanxOS/操作系统之路-FlyanxOS-微内核向-教程/图片/计算机内存分布图.png)

## 导入一些软盘常量

```assembly
; -------------------------------------------------------------------------
; 基于 FAT12 头的一些常量定义，如果头信息改变，下面的常量可能也要做相应改变
; -------------------------------------------------------------------------
; BPB_FATSz16
FATSz			equ	9

; 根目录占用空间:
; RootDirSectors = ((BPB_RootEntCnt*32)+(BPB_BytsPerSec–1))/BPB_BytsPerSec
; 但如果按照此公式代码过长，故定义此宏
RootDirSectors		equ	14

; Root Directory 的第一个扇区号	= BPB_RsvdSecCnt + (BPB_NumFATs; FATSz)
SectorNoOfRootDirectory	equ	19

; FAT1 的第一个扇区号	= BPB_RsvdSecCnt
SectorNoOfFAT1		equ	1

; DeltaSectorNo = BPB_RsvdSecCnt + (BPB_NumFATs; FATSz) - 2
; 文件的开始Sector号 = DirEntry中的开始Sector号 + 根目录占用Sector数目
;                      + DeltaSectorNo
DeltaSectorNo		equ	17
```

## 读取磁盘扇区

​	虽然我们最简单的加载程序完成了，但是它无法被执行，因为一切都是从引导程序开始的，所以我们需要读取软盘中的数据，我们马上编写读取软盘扇区数据到内存中的函数。

​	首先，既然是读软盘，那么我们就难免不得不用到BIOS中断了，通过查询BIOS中断手册，我们马上就能知道BIOS为我们提供的读写硬盘中断，我们只需要用到读取操作，我将需要用到的两个操作列出，如下所示：

 - 复位驱动器

   中断号：0x13	功能号：ah=0

   dl：驱动器号（0、1、2表示A、B、C盘，以此类推）

- 从磁盘中读取数据，读取到es:bx指向的缓冲区中

  中断号：0x13	功能号：ah=2

  ch：柱面（磁道）号

  dh：磁头号

  es:bx：数据缓冲区

  al：要读取几个扇区？

  cl：起始扇区号

  dl：驱动器号（0、1、2表示A、B、C盘，以此类推）

从上面我们可以看出读取磁盘中断的参数有些复杂，不是我们想的那样简单的给出起始扇区就可以了。它需要的是柱面号、磁头号以及在当前柱面上的扇区号3个分量，所以我们必须得先求得这些值。

​	对于1.44MB的软盘来说，它总共有两面（磁头号0和1），而每面有80个磁道（磁道0~79），每个磁道又有18个扇区（扇区号1~18，为什么又不从零开始了，真是奇怪！）。下面的公式就是软盘容量的由来：

​	2 x 80 x 18 x 512 = 1474560 = 0x168000 = 1.44MB

​	于是呢，磁头号、柱面（磁道）号和起始扇区可以用下图的方法进行计算。2 -> 10 -> 01 -> 2 >> 1 = 01 = 1

![](/media/flyan/Office/工程/FlyanxOS/操作系统之路-FlyanxOS-微内核向-教程/图片/2020-02-10_23-00.png)

​	这个函数的编写过程比较复杂，而且容易出错，在这，我直接引用TINIX的读取扇区的函数。

````assembly
;----------------------------------------------------------------------------
; 函数名: ReadSector
;----------------------------------------------------------------------------
; 作用:
;	从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
ReadSector:
	; -----------------------------------------------------------------------
	; 怎样由扇区号求扇区在磁盘中的位置 (扇区号 -> 柱面号, 起始扇区, 磁头号)
	; -----------------------------------------------------------------------
	; 设扇区号为 x
	;                           ┌ 柱面号 = y >> 1
	;       x           ┌ 商 y ┤
	; -------------- => ┤      └ 磁头号 = y & 1
	;  每磁道扇区数       │
	;                   └ 余 z => 起始扇区号 = z + 1
	push	bp
	mov	bp, sp
	sub	esp, 2			; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2]

	mov	byte [bp-2], cl
	push	bx			; 保存 bx
	mov	bl, [BPB_SecPerTrk]	; bl: 除数
	div	bl			; y 在 al 中, z 在 ah 中
	inc	ah			; z ++
	mov	cl, ah			; cl <- 起始扇区号
	mov	dh, al			; dh <- y
	shr	al, 1			; y >> 1 (其实是 y/BPB_NumHeads, 这里BPB_NumHeads=2)
	mov	ch, al			; ch <- 柱面号
	and	dh, 1			; dh & 1 = 磁头号
	pop	bx			; 恢复 bx
	; 至此, "柱面号, 起始扇区, 磁头号" 全部得到 ^^^^^^^^^^^^^^^^^^^^^^^^
	mov	dl, [BS_DrvNum]		; 驱动器号 (0 表示 A 盘)
.GoOnReading:
	mov	ah, 2				; 读
	mov	al, byte [bp-2]		; 读 al 个扇区
	int	13h
	jc	.GoOnReading		; 如果读取错误 CF 会被置为 1, 这时就不停地读, 直到正确为止

	add	esp, 2
	pop	bp

	ret
````

## 从FAT12表中找出一个文件的所有项

​	现在我们装入一个扇区已经是非常的轻松了，但是如果一个文件大一点就很难受了，我们需要想办法找到该文件的所有数据所在的扇区，然后加载它们。

​	不过还好的是，我们的软盘已经有了一个简单的FAT12文件系统，可以把这项工作稍微降低一点难度，我们现在需要编写一个专门的函数用来读取某个扇区中的FAT项，以此来帮助我们加载文件。

![](/media/flyan/Office/工程/FlyanxOS/操作系统之路-FlyanxOS-微内核向-教程/图片/从FAT表中得到一个FAT项的值.png)









​	
